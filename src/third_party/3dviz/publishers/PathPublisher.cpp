// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file PathPublisher.cpp
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastrtps/participant/Participant.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <fastrtps/publisher/Publisher.h>
#include <fastrtps/attributes/PublisherAttributes.h>

#include <fastrtps/Domain.h>

#include <fastrtps/utils/eClock.h>

#include "PathPublisher.h"

#include "PoseStamped.h"
#include "Pose.h"
#include "Point.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

PathPublisher::PathPublisher() : mp_participant(nullptr), mp_publisher_proximity(nullptr) {}

PathPublisher::~PathPublisher() {	Domain::removeParticipant(mp_participant);}

bool PathPublisher::init(CameraVolume *cam_volume)
{
    _cam_volume = cam_volume;

    ParticipantAttributes PParam;
    PParam.rtps.builtin.domainId = 0;
    PParam.rtps.builtin.leaseDuration = c_TimeInfinite;
    PParam.rtps.setName("path_publisher");
    mp_participant = Domain::createParticipant(PParam);

    if(mp_participant == nullptr)
    {
        return false;
    }

    Domain::registerType(mp_participant, static_cast<TopicDataType*>(&myType));

    PublisherAttributes Wparam;
    Wparam.topic.topicKind = NO_KEY;
    Wparam.topic.topicDataType = myType.getName();
    Wparam.topic.topicName = "rt/camera_cone";

    mp_publisher_camera_cone = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher_camera_cone == nullptr)
    {
        std::cout << "Creating publisher failed" << std::endl;

        return false;
    }

    Wparam.topic.topicName = "rt/safe_zone";

    mp_publisher_safe_zone = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher_safe_zone == nullptr)
    {
        std::cout << "Creating publisher failed" << std::endl;
        return false;
    }

    Wparam.topic.topicName = "rt/proximity";

    mp_publisher_proximity = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher_proximity == nullptr)
    {
        std::cout << "Creating publisher failed" << std::endl;
        return false;
    }

    Wparam.topic.topicName = "rt/target";

    mp_publisher_target = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher_target == nullptr)
    {
        std::cout << "Creating publisher failed" << std::endl;
        return false;
    }

    Wparam.topic.topicName = "rt/drone_path";

    mp_publisher_drone_path = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher_drone_path == nullptr)
    {
        std::cout << "Creating publisher failed" << std::endl;
        return false;
    }

    Wparam.topic.topicName = "rt/insect_path";

    mp_publisher_insect_path = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher_insect_path == nullptr)
    {
        std::cout << "Creating publisher failed" << std::endl;
        return false;
    }

    Wparam.topic.topicName = "rt/hunt_cone";

    mp_publisher_hunt_cone = Domain::createPublisher(mp_participant,Wparam,static_cast<PublisherListener*>(&m_listener));

    if(mp_publisher_hunt_cone == nullptr)
    {
        std::cout << "Creating publisher failed" << std::endl;
        return false;
    }

    return true;
}

void PathPublisher::PubListener::onPublicationMatched(Publisher* pub,MatchingInfo& info)
{
    (void)pub;

    if (info.status == MATCHED_MATCHING)
    {
        n_matched++;
        std::cout << "Publisher matched" << std::endl;
    }
    else
    {
        n_matched--;
        std::cout << "Publisher unmatched" << std::endl;
    }
}

void PathPublisher::add_camera_cone(std::vector<geometry_msgs::msg::PoseStamped> &poses, cv::Mat point, int64 time, std::string frame_id)
{
    double x = static_cast<double>(point.at<float>(0));
    double y = static_cast<double>(point.at<float>(1));
    double z = static_cast<double>(point.at<float>(2));
    add_point(poses, x, y, z, time, frame_id);
}

void PathPublisher::add_camera_cone(std::vector<geometry_msgs::msg::PoseStamped> &poses, int64 time)
{
    cv::Mat point;

    add_camera_cone(poses, _cam_volume->top_right_front(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->top_right_back(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->top_left_back(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_left_back(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_right_back(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_right_front(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_left_front(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->top_left_front(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->top_left_back(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_left_back(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_left_front(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->top_left_front(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_right_front(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->bottom_right_back(), time, "pats_frame");
    add_camera_cone(poses, _cam_volume->top_right_back(), time, "pats_frame");
}

void PathPublisher::add_hunt_cone(std::vector<geometry_msgs::msg::PoseStamped> &poses, int64 time)
{
    cv::Mat point;

    if (_cam_volume->top_right_front_hunt().rows > 0)
    {
        add_camera_cone(poses, _cam_volume->top_right_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->top_right_back_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->top_left_back_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_left_back_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_right_back_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_right_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_left_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->top_left_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->top_right_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_right_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_right_back_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->top_right_back_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->top_left_back_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->top_left_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_left_front_hunt(), time, "pats_frame");
        add_camera_cone(poses, _cam_volume->bottom_left_back_hunt(), time, "pats_frame");
    }
}

void PathPublisher::set_target(double x, double y, double z, int64 time)
{
    add_point(_target_poses, x, y, z, time, "pats_frame");
}

void PathPublisher::run(int64_t time)
{
    nav_msgs::msg::Path st;
    nav_msgs::msg::Path st_hunt_cone;
    std::vector<geometry_msgs::msg::PoseStamped> poses;
    std::vector<geometry_msgs::msg::PoseStamped> hunt_cone_poses;
    std_msgs::msg::Header header;
    builtin_interfaces::msg::Time t;

    add_camera_cone(poses, time);
    add_hunt_cone(hunt_cone_poses, time);

    t.sec(static_cast<int32_t>(time / 1e9l));
    t.nanosec(static_cast<uint32_t>(time % static_cast<int64_t>(1e9)));
    header.frame_id("pats_frame");
    header.stamp(t);

    st.poses(poses);
    st.header(header);
    mp_publisher_camera_cone->write(&st);

    st_hunt_cone.poses(hunt_cone_poses);
    st_hunt_cone.header(header);
    mp_publisher_hunt_cone->write(&st_hunt_cone);

    if (_drone_poses.size() > 200)
    {
        _drone_poses.erase (_drone_poses.begin(),_drone_poses.begin()+50);
    }

    if (_insect_poses.size() > 200)
    {
        _insect_poses.erase (_insect_poses.begin(),_insect_poses.begin()+50);
    }

    if (_proximity_poses.size() >400)
    {
        _proximity_poses.erase (_proximity_poses.begin(),_proximity_poses.begin()+50);
    }

    nav_msgs::msg::Path proximity_path;
    header.frame_id("pats_frame");
    proximity_path.header(header);
    proximity_path.poses(_proximity_poses);
    mp_publisher_proximity->write(&proximity_path);

    nav_msgs::msg::Path drone_path;
    header.frame_id("pats_frame");
    drone_path.header(header);
    drone_path.poses(_drone_poses);
    mp_publisher_drone_path->write(&drone_path);

    nav_msgs::msg::Path insect_path;
    header.frame_id("pats_frame");
    insect_path.header(header);
    insect_path.poses(_insect_poses);
    mp_publisher_insect_path->write(&insect_path);

    nav_msgs::msg::Path target_path;

    header.frame_id("pats_frame");
    target_path.header(header);
    target_path.poses(_target_poses);
    mp_publisher_target->write(&target_path);

    _target_poses.resize(0);
}

void PathPublisher::add_drone_pos(double x, double y, double z, int64_t time)
{
    add_point(_drone_poses, x, y, z, time, "pats_frame");
    add_point(_proximity_poses, x, y, z, time, "pats_frame");
    add_point(_target_poses, x, y, z, time, "pats_frame");
}

void PathPublisher::add_insect_pos(double x, double y, double z, int64_t time)
{
    add_point(_insect_poses, x, y, z, time, "pats_frame");
    add_point(_proximity_poses, x, y, z, time, "pats_frame");
}

void PathPublisher::add_point(std::vector<geometry_msgs::msg::PoseStamped> &poses, double x, double y, double z, int64_t time, std::string frame_id)
{
    geometry_msgs::msg::PoseStamped pose_stamped;
    geometry_msgs::msg::Pose pose;
    geometry_msgs::msg::Point point;
    std_msgs::msg::Header header;
    builtin_interfaces::msg::Time t;

    point.x(x);
    point.y(y);
    point.z(z);
    pose.position(point);
    pose_stamped.pose(pose);

    t.sec(static_cast<int32_t>(time / 1e9l));
    t.nanosec(static_cast<uint32_t>(time % static_cast<int64_t>(1e9)));

    header.frame_id(frame_id);
    header.stamp(t);

    pose_stamped.header(header);
    poses.push_back(pose_stamped);
}
